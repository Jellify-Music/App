diff --git a/node_modules/react-native-nitro-player/ios/core/TrackPlayerCore.swift b/node_modules/react-native-nitro-player/ios/core/TrackPlayerCore.swift
index 8677316..b9585a5 100644
--- a/node_modules/react-native-nitro-player/ios/core/TrackPlayerCore.swift
+++ b/node_modules/react-native-nitro-player/ios/core/TrackPlayerCore.swift
@@ -280,8 +280,7 @@ class TrackPlayerCore: NSObject {
     print("\nðŸ TrackPlayerCore: Track finished playing")
 
     guard let finishedItem = notification.object as? AVPlayerItem else {
-      print("âš ï¸ Cannot identify finished item")
-      skipToNext()
+      // Don't call skipToNext â€” AVQueuePlayer with actionAtItemEnd = .advance already auto-advances
       return
     }
 
@@ -352,7 +351,9 @@ class TrackPlayerCore: NSObject {
       print("ðŸ” TrackPlayerCore: Repeat mode is OFF")
     }
 
-    // Track ended naturally
+    // Track ended naturally â€” notify with .end reason
+    // AVQueuePlayer with actionAtItemEnd = .advance auto-advances to next item
+    // The KVO observer (currentItemDidChange) will handle the track change notification
     notifyTrackChange(
       getCurrentTrack()
         ?? TrackItem(
@@ -365,9 +366,6 @@ class TrackPlayerCore: NSObject {
           artwork: nil,
           extraPayload: nil
         ), .end)
-
-    // Try to play next track
-    skipToNext()
   }
 
   @objc private func playerItemFailedToPlayToEndTime(notification: Notification) {
@@ -642,12 +640,21 @@ class TrackPlayerCore: NSObject {
   func updatePlaylist(playlistId: String) {
     DispatchQueue.main.async { [weak self] in
       guard let self = self else { return }
-      if self.currentPlaylistId == playlistId {
+      guard self.currentPlaylistId == playlistId,
         let playlist = self.playlistManager.getPlaylist(playlistId: playlistId)
-        if let playlist = playlist {
-          self.updatePlayerQueue(tracks: playlist.tracks)
-        }
+      else { return }
+
+      // If nothing is playing yet, do a full load
+      guard let player = self.player, player.currentItem != nil else {
+        self.updatePlayerQueue(tracks: playlist.tracks)
+        return
       }
+
+      // Update tracks list without interrupting playback
+      self.currentTracks = playlist.tracks
+
+      // Rebuild only the items after the currently playing item
+      self.rebuildAVQueueFromCurrentPosition()
     }
   }
 
@@ -1134,21 +1141,34 @@ class TrackPlayerCore: NSObject {
     var queue: [TrackItem] = []
 
     // Add tracks before current (original playlist)
-    if currentTrackIndex > 0 {
-      queue.append(contentsOf: Array(currentTracks[0..<currentTrackIndex]))
+    // When a temp track is playing, include the original track at currentTrackIndex
+    // (it already played before the temp track started)
+    let beforeEnd = currentTemporaryType != .none
+      ? min(currentTrackIndex + 1, currentTracks.count) : currentTrackIndex
+    if beforeEnd > 0 {
+      queue.append(contentsOf: Array(currentTracks[0..<beforeEnd]))
     }
 
-    // Add current track
+    // Add current track (temp or original)
     if let current = getCurrentTrack() {
       queue.append(current)
     }
 
     // Add playNext stack (LIFO - most recently added plays first)
-    // Stack is already in correct order since we insert at position 0
-    queue.append(contentsOf: playNextStack)
+    // Skip index 0 if current track is from playNext (it's already added as current)
+    if currentTemporaryType == .playNext && playNextStack.count > 1 {
+      queue.append(contentsOf: Array(playNextStack.dropFirst()))
+    } else if currentTemporaryType != .playNext {
+      queue.append(contentsOf: playNextStack)
+    }
 
     // Add upNext queue (in order, FIFO)
-    queue.append(contentsOf: upNextQueue)
+    // Skip index 0 if current track is from upNext (it's already added as current)
+    if currentTemporaryType == .upNext && upNextQueue.count > 1 {
+      queue.append(contentsOf: Array(upNextQueue.dropFirst()))
+    } else if currentTemporaryType != .upNext {
+      queue.append(contentsOf: upNextQueue)
+    }
 
     // Add remaining original tracks
     if currentTrackIndex + 1 < currentTracks.count {
@@ -1314,39 +1334,23 @@ class TrackPlayerCore: NSObject {
   private func skipToNextInternal() {
     guard let queuePlayer = self.player else { return }
 
-    print("\nâ­ï¸ TrackPlayerCore: SKIP TO NEXT")
-    print("   BEFORE:")
-    print("      currentTrackIndex: \(self.currentTrackIndex)")
-    print("      Total tracks in currentTracks: \(self.currentTracks.count)")
-    print("      Items in player queue: \(queuePlayer.items().count)")
-
-    if let currentItem = queuePlayer.currentItem, let trackId = currentItem.trackId {
-      if let track = self.currentTracks.first(where: { $0.id == trackId }) {
-        print("      Currently playing: \(track.title) (ID: \(track.id))")
+    // Remove current temp track from its list before advancing
+    if let trackId = queuePlayer.currentItem?.trackId {
+      if currentTemporaryType == .playNext {
+        if let idx = playNextStack.firstIndex(where: { $0.id == trackId }) {
+          playNextStack.remove(at: idx)
+        }
+      } else if currentTemporaryType == .upNext {
+        if let idx = upNextQueue.firstIndex(where: { $0.id == trackId }) {
+          upNextQueue.remove(at: idx)
+        }
       }
     }
 
-    // Check if there are more items in the queue
-    if self.currentTrackIndex + 1 < self.currentTracks.count {
-      print("   ðŸ”„ Calling advanceToNextItem()...")
+    // Check if there are more items in the player queue
+    if queuePlayer.items().count > 1 {
       queuePlayer.advanceToNextItem()
-
-      // NOTE: Don't manually update currentTrackIndex here!
-      // The KVO observer (currentItemDidChange) will update it automatically
-
-      print("   AFTER advanceToNextItem():")
-      print("      Items in player queue: \(queuePlayer.items().count)")
-
-      if let newCurrentItem = queuePlayer.currentItem, let trackId = newCurrentItem.trackId {
-        if let track = self.currentTracks.first(where: { $0.id == trackId }) {
-          print("      New current item: \(track.title) (ID: \(track.id))")
-        }
-      }
-
-      print("   â³ Waiting for KVO observer to update index...")
     } else {
-      print("   âš ï¸ No more tracks in playlist")
-      // At end of playlist - stop or loop
       queuePlayer.pause()
       self.notifyPlaybackStateChange(.stopped, .end)
     }
@@ -1365,29 +1369,31 @@ class TrackPlayerCore: NSObject {
   private func skipToPreviousInternal() {
     guard let queuePlayer = self.player else { return }
 
-    print("\nâ®ï¸ TrackPlayerCore: SKIP TO PREVIOUS")
-    print("   Current index: \(self.currentTrackIndex)")
-    print("   Temporary type: \(self.currentTemporaryType)")
-    print("   Current time: \(queuePlayer.currentTime().seconds)s")
-
     let currentTime = queuePlayer.currentTime()
     if currentTime.seconds > Constants.skipToPreviousThreshold {
       // If more than threshold seconds in, restart current track
-      print(
-        "   ðŸ”„ More than \(Int(Constants.skipToPreviousThreshold))s in, restarting current track")
       queuePlayer.seek(to: .zero)
     } else if self.currentTemporaryType != .none {
-      // Playing temporary track - just restart it (temps are not navigable backwards)
-      print("   ðŸ”„ Playing temporary track - restarting it (temps not navigable backwards)")
-      queuePlayer.seek(to: .zero)
+      // Playing temporary track â€” remove from its list, then restart
+      if let trackId = queuePlayer.currentItem?.trackId {
+        if currentTemporaryType == .playNext {
+          if let idx = playNextStack.firstIndex(where: { $0.id == trackId }) {
+            playNextStack.remove(at: idx)
+          }
+        } else if currentTemporaryType == .upNext {
+          if let idx = upNextQueue.firstIndex(where: { $0.id == trackId }) {
+            upNextQueue.remove(at: idx)
+          }
+        }
+      }
+      // Go to current original track position (skip back from temp)
+      self.playFromIndex(index: self.currentTrackIndex)
     } else if self.currentTrackIndex > 0 {
       // Go to previous track in original playlist
       let previousIndex = self.currentTrackIndex - 1
-      print("   â®ï¸ Going to previous track at index \(previousIndex)")
       self.playFromIndex(index: previousIndex)
     } else {
       // Already at first track, restart it
-      print("   ðŸ”„ Already at first track, restarting it")
       queuePlayer.seek(to: .zero)
     }
   }
@@ -1577,44 +1583,38 @@ class TrackPlayerCore: NSObject {
   }
 
   private func skipToIndexInternal(index: Int) -> Bool {
-    print("\nðŸŽ¯ TrackPlayerCore: SKIP TO INDEX \(index)")
-
     // Get actual queue to validate index and determine position
     let actualQueue = getActualQueueInternal()
     let totalQueueSize = actualQueue.count
 
     // Validate index
-    guard index >= 0 && index < totalQueueSize else {
-      print("   âŒ Invalid index \(index), queue size is \(totalQueueSize)")
-      return false
-    }
+    guard index >= 0 && index < totalQueueSize else { return false }
+
+    // Calculate queue section boundaries using effective sizes
+    // (reduced by 1 when current track is from that temp list, matching getActualQueueInternal)
+    // When temp is playing, the original track at currentTrackIndex is included in "before",
+    // so the current playing position shifts by 1
+    let currentPos = currentTemporaryType != .none
+      ? currentTrackIndex + 1 : currentTrackIndex
+    let effectivePlayNextSize = currentTemporaryType == .playNext
+      ? max(0, playNextStack.count - 1) : playNextStack.count
+    let effectiveUpNextSize = currentTemporaryType == .upNext
+      ? max(0, upNextQueue.count - 1) : upNextQueue.count
 
-    // Calculate queue section boundaries
-    // ActualQueue structure: [before_current] + [current] + [playNext] + [upNext] + [remaining_original]
-    let currentPos = currentTrackIndex
     let playNextStart = currentPos + 1
-    let playNextEnd = playNextStart + playNextStack.count
+    let playNextEnd = playNextStart + effectivePlayNextSize
     let upNextStart = playNextEnd
-    let upNextEnd = upNextStart + upNextQueue.count
+    let upNextEnd = upNextStart + effectiveUpNextSize
     let originalRemainingStart = upNextEnd
 
-    print("   Queue structure:")
-    print("      currentPos: \(currentPos)")
-    print("      playNextStart: \(playNextStart), playNextEnd: \(playNextEnd)")
-    print("      upNextStart: \(upNextStart), upNextEnd: \(upNextEnd)")
-    print("      originalRemainingStart: \(originalRemainingStart)")
-    print("      totalQueueSize: \(totalQueueSize)")
-
     // Case 1: Target is before current - use playFromIndex on original
     if index < currentPos {
-      print("   ðŸ“ Target is before current, jumping to original playlist index \(index)")
       playFromIndexInternal(index: index)
       return true
     }
 
     // Case 2: Target is current - seek to beginning
     if index == currentPos {
-      print("   ðŸ“ Target is current track, seeking to beginning")
       player?.seek(to: .zero)
       return true
     }
@@ -1622,12 +1622,13 @@ class TrackPlayerCore: NSObject {
     // Case 3: Target is in playNext section
     if index >= playNextStart && index < playNextEnd {
       let playNextIndex = index - playNextStart
-      print("   ðŸ“ Target is in playNext section at position \(playNextIndex)")
+      // Offset by 1 if current is from playNext (index 0 is already playing)
+      let actualListIndex = currentTemporaryType == .playNext
+        ? playNextIndex + 1 : playNextIndex
 
       // Remove tracks before the target from playNext (they're being skipped)
-      if playNextIndex > 0 {
-        playNextStack.removeFirst(playNextIndex)
-        print("      Removed \(playNextIndex) tracks from playNext stack")
+      if actualListIndex > 0 {
+        playNextStack.removeFirst(actualListIndex)
       }
 
       // Rebuild queue and advance
@@ -1639,16 +1640,16 @@ class TrackPlayerCore: NSObject {
     // Case 4: Target is in upNext section
     if index >= upNextStart && index < upNextEnd {
       let upNextIndex = index - upNextStart
-      print("   ðŸ“ Target is in upNext section at position \(upNextIndex)")
+      // Offset by 1 if current is from upNext (index 0 is already playing)
+      let actualListIndex = currentTemporaryType == .upNext
+        ? upNextIndex + 1 : upNextIndex
 
       // Clear all playNext tracks (they're being skipped)
       playNextStack.removeAll()
-      print("      Cleared all playNext tracks")
 
       // Remove tracks before target from upNext
-      if upNextIndex > 0 {
-        upNextQueue.removeFirst(upNextIndex)
-        print("      Removed \(upNextIndex) tracks from upNext queue")
+      if actualListIndex > 0 {
+        upNextQueue.removeFirst(actualListIndex)
       }
 
       // Rebuild queue and advance
@@ -1659,35 +1660,21 @@ class TrackPlayerCore: NSObject {
 
     // Case 5: Target is in remaining original tracks
     if index >= originalRemainingStart {
-      // Get the target track directly from actualQueue
       let targetTrack = actualQueue[index]
 
-      print("   ðŸ“ Case 5: Target is in remaining original tracks")
-      print("      targetTrack.id: \(targetTrack.id)")
-      print("      currentTracks.count: \(currentTracks.count)")
-      print("      currentTracks IDs: \(currentTracks.map { $0.id })")
-
       // Find this track's index in the original playlist
       guard let originalIndex = currentTracks.firstIndex(where: { $0.id == targetTrack.id }) else {
-        print("   âŒ Could not find track \(targetTrack.id) in original playlist")
-        print("      Available tracks: \(currentTracks.map { $0.id })")
         return false
       }
 
-      print("      originalIndex found: \(originalIndex)")
-
       // Clear all temporary tracks (they're being skipped)
       playNextStack.removeAll()
       upNextQueue.removeAll()
       currentTemporaryType = .none
-      print("      Cleared all temporary tracks")
 
-      // Play from the original playlist index
-      let success = playFromIndexInternalWithResult(index: originalIndex)
-      return success
+      return playFromIndexInternalWithResult(index: originalIndex)
     }
 
-    print("   âŒ Unexpected case, index \(index) not handled")
     return false
   }
 
@@ -1798,6 +1785,7 @@ class TrackPlayerCore: NSObject {
     if self.player?.currentItem != nil {
       self.rebuildAVQueueFromCurrentPosition()
     }
+    mediaSessionManager?.onQueueChanged()
   }
 
   /**
@@ -1827,6 +1815,7 @@ class TrackPlayerCore: NSObject {
     if self.player?.currentItem != nil {
       self.rebuildAVQueueFromCurrentPosition()
     }
+    mediaSessionManager?.onQueueChanged()
   }
 
   /**
@@ -1836,24 +1825,26 @@ class TrackPlayerCore: NSObject {
   private func rebuildAVQueueFromCurrentPosition() {
     guard let player = self.player else { return }
 
-    print("\nðŸ”„ TrackPlayerCore: REBUILDING QUEUE FROM CURRENT POSITION")
-    print("   playNext stack: \(playNextStack.count) tracks")
-    print("   upNext queue: \(upNextQueue.count) tracks")
-
-    // Don't interrupt currently playing item
     let currentItem = player.currentItem
     let playingItems = player.items()
 
-    // Build new queue order:
-    // [playNext stack] + [upNext queue] + [remaining original tracks]
     var newQueueTracks: [TrackItem] = []
 
     // Add playNext stack (LIFO - most recently added plays first)
-    // Stack is already in correct order since we insert at position 0
-    newQueueTracks.append(contentsOf: playNextStack)
+    // Skip index 0 if current track is from playNext (it's already playing)
+    if currentTemporaryType == .playNext && playNextStack.count > 1 {
+      newQueueTracks.append(contentsOf: Array(playNextStack.dropFirst()))
+    } else if currentTemporaryType != .playNext {
+      newQueueTracks.append(contentsOf: playNextStack)
+    }
 
     // Add upNext queue (in order, FIFO)
-    newQueueTracks.append(contentsOf: upNextQueue)
+    // Skip index 0 if current track is from upNext (it's already playing)
+    if currentTemporaryType == .upNext && upNextQueue.count > 1 {
+      newQueueTracks.append(contentsOf: Array(upNextQueue.dropFirst()))
+    } else if currentTemporaryType != .upNext {
+      newQueueTracks.append(contentsOf: upNextQueue)
+    }
 
     // Add remaining original tracks
     if currentTrackIndex + 1 < currentTracks.count {
@@ -1861,8 +1852,6 @@ class TrackPlayerCore: NSObject {
       newQueueTracks.append(contentsOf: remainingOriginal)
     }
 
-    print("   New queue: \(newQueueTracks.count) tracks total")
-
     // Remove all items from player EXCEPT the currently playing one
     for item in playingItems where item != currentItem {
       player.remove(item)
@@ -1877,7 +1866,6 @@ class TrackPlayerCore: NSObject {
       }
     }
 
-    print("   âœ… Queue rebuilt successfully")
   }
 
   /**
diff --git a/node_modules/react-native-nitro-player/ios/media/MediaSessionManager.swift b/node_modules/react-native-nitro-player/ios/media/MediaSessionManager.swift
index 0bfa61c..90cf818 100644
--- a/node_modules/react-native-nitro-player/ios/media/MediaSessionManager.swift
+++ b/node_modules/react-native-nitro-player/ios/media/MediaSessionManager.swift
@@ -15,10 +15,6 @@ class MediaSessionManager {
   // MARK: - Constants
 
   private enum Constants {
-    // Seek intervals (in seconds)
-    static let seekInterval: Double = 10.0
-
-    // Artwork size
     static let artworkSize: CGFloat = 500.0
   }
 
@@ -27,10 +23,11 @@ class MediaSessionManager {
   private var trackPlayerCore: TrackPlayerCore?
   private var artworkCache: [String: UIImage] = [:]
 
-  private var androidAutoEnabled: Bool = false
-  private var carPlayEnabled: Bool = false
   private var showInNotification: Bool = true
 
+  // Tracks the artwork URL currently shown so we can discard stale async loads
+  private var lastArtworkUrl: String?
+
   init() {
     setupRemoteCommandCenter()
   }
@@ -44,47 +41,165 @@ class MediaSessionManager {
     carPlayEnabled: Bool?,
     showInNotification: Bool?
   ) {
-    if let androidAutoEnabled = androidAutoEnabled {
-      self.androidAutoEnabled = androidAutoEnabled
-    }
-    if let carPlayEnabled = carPlayEnabled {
-      self.carPlayEnabled = carPlayEnabled
-      // CarPlay is handled by the app's CarPlaySceneDelegate
-      // We just maintain the flag here for reference
-    }
     if let showInNotification = showInNotification {
       self.showInNotification = showInNotification
-      if showInNotification {
-        updateNowPlayingInfo()
+    }
+    refresh()
+  }
+
+  // MARK: - Single refresh entry point
+  //
+  // All public callbacks route here. Always dispatches to main thread so
+  // MPNowPlayingInfoCenter and MPRemoteCommandCenter are only touched from main.
+
+  func refresh() {
+    if Thread.isMainThread {
+      refreshInternal()
+    } else {
+      DispatchQueue.main.async { [weak self] in
+        self?.refreshInternal()
+      }
+    }
+  }
+
+  // Convenience aliases used by TrackPlayerCore call sites
+  func updateNowPlayingInfo() { refresh() }
+  func onTrackChanged() { refresh() }
+  func onPlaybackStateChanged() { refresh() }
+  func onQueueChanged() { refresh() }
+
+  // MARK: - Core internal update (main thread only)
+
+  private func refreshInternal() {
+    guard showInNotification else {
+      clearNowPlayingInfo()
+      disableAllCommands()
+      return
+    }
+
+    guard let core = trackPlayerCore,
+      let track = core.getCurrentTrack()
+    else {
+      clearNowPlayingInfo()
+      disableAllCommands()
+      return
+    }
+
+    // Fetch snapshot once â€” both calls are cheap on main thread (no sync overhead)
+    let state = core.getState()
+    let queue = core.getActualQueue()
+
+    // Find the actual position of the current track inside the actual queue.
+    // state.currentIndex is the original-playlist index which is wrong when a
+    // temp (playNext / upNext) track is playing.
+    let positionInQueue = queue.firstIndex(where: { $0.id == track.id }) ?? -1
+
+    updateNowPlayingInfoInternal(track: track, state: state, queue: queue, positionInQueue: positionInQueue)
+    updateCommandCenterState(state: state, queue: queue, positionInQueue: positionInQueue)
+  }
+
+  // MARK: - Now Playing Info
+
+  private func updateNowPlayingInfoInternal(
+    track: TrackItem,
+    state: PlayerState,
+    queue: [TrackItem],
+    positionInQueue: Int
+  ) {
+    let playerDuration = state.totalDuration
+    let effectiveDuration: Double
+    if playerDuration > 0 && !playerDuration.isNaN && !playerDuration.isInfinite {
+      effectiveDuration = playerDuration
+    } else if track.duration > 0 {
+      effectiveDuration = track.duration
+    } else {
+      effectiveDuration = 0
+    }
+
+    let currentPosition = state.currentPosition
+    let safePosition = currentPosition.isNaN || currentPosition.isInfinite ? 0 : currentPosition
+    let isPlaying = state.currentState == .playing
+
+    var nowPlayingInfo: [String: Any] = [
+      MPMediaItemPropertyTitle: track.title,
+      MPMediaItemPropertyArtist: track.artist,
+      MPMediaItemPropertyAlbumTitle: track.album,
+      MPNowPlayingInfoPropertyElapsedPlaybackTime: safePosition,
+      MPMediaItemPropertyPlaybackDuration: effectiveDuration,
+      MPNowPlayingInfoPropertyPlaybackRate: isPlaying ? 1.0 : 0.0,
+      MPNowPlayingInfoPropertyDefaultPlaybackRate: 1.0,
+      MPNowPlayingInfoPropertyPlaybackQueueCount: max(1, queue.count),
+      MPNowPlayingInfoPropertyPlaybackQueueIndex: max(0, positionInQueue),
+    ]
+
+    // Artwork: use cache synchronously when available, otherwise kick off async load
+    if let artwork = track.artwork, case .second(let artworkUrl) = artwork {
+      lastArtworkUrl = artworkUrl
+      if let cachedImage = artworkCache[artworkUrl] {
+        nowPlayingInfo[MPMediaItemPropertyArtwork] = MPMediaItemArtwork(
+          boundsSize: CGSize(width: Constants.artworkSize, height: Constants.artworkSize),
+          requestHandler: { _ in cachedImage }
+        )
       } else {
-        clearNowPlayingInfo()
+        // Write info first without artwork, then patch it in when loaded
+        MPNowPlayingInfoCenter.default().nowPlayingInfo = nowPlayingInfo
+        loadArtwork(url: artworkUrl) { [weak self] image in
+          guard let self = self, let image = image else { return }
+          // Discard if track changed while loading
+          guard self.lastArtworkUrl == artworkUrl else { return }
+          var updated = MPNowPlayingInfoCenter.default().nowPlayingInfo ?? [:]
+          updated[MPMediaItemPropertyArtwork] = MPMediaItemArtwork(
+            boundsSize: CGSize(width: Constants.artworkSize, height: Constants.artworkSize),
+            requestHandler: { _ in image }
+          )
+          MPNowPlayingInfoCenter.default().nowPlayingInfo = updated
+        }
+        return
       }
+    } else {
+      lastArtworkUrl = nil
     }
+
+    MPNowPlayingInfoCenter.default().nowPlayingInfo = nowPlayingInfo
   }
 
+  // MARK: - Command Center State
+
   private func setupRemoteCommandCenter() {
     let commandCenter = MPRemoteCommandCenter.shared()
 
-    // Play command
+    // Clear any previously registered targets before adding fresh ones.
+    // Prevents duplicate handlers if this were ever called more than once.
+    commandCenter.playCommand.removeTarget(nil)
+    commandCenter.pauseCommand.removeTarget(nil)
+    commandCenter.togglePlayPauseCommand.removeTarget(nil)
+    commandCenter.nextTrackCommand.removeTarget(nil)
+    commandCenter.previousTrackCommand.removeTarget(nil)
+    commandCenter.seekForwardCommand.removeTarget(nil)
+    commandCenter.seekBackwardCommand.removeTarget(nil)
+    commandCenter.changePlaybackPositionCommand.removeTarget(nil)
+
+    // Play
     commandCenter.playCommand.isEnabled = true
     commandCenter.playCommand.addTarget { [weak self] _ in
-      self?.trackPlayerCore?.play()
+      guard let core = self?.trackPlayerCore else { return .commandFailed }
+      core.play()
       return .success
     }
 
-    // Pause command
+    // Pause
     commandCenter.pauseCommand.isEnabled = true
     commandCenter.pauseCommand.addTarget { [weak self] _ in
-      self?.trackPlayerCore?.pause()
+      guard let core = self?.trackPlayerCore else { return .commandFailed }
+      core.pause()
       return .success
     }
 
     // Toggle play/pause
     commandCenter.togglePlayPauseCommand.isEnabled = true
     commandCenter.togglePlayPauseCommand.addTarget { [weak self] _ in
-      guard let self = self, let core = self.trackPlayerCore else { return .commandFailed }
-      let state = core.getState()
-      if state.currentState == .playing {
+      guard let core = self?.trackPlayerCore else { return .commandFailed }
+      if core.getState().currentState == .playing {
         core.pause()
       } else {
         core.play()
@@ -92,27 +207,28 @@ class MediaSessionManager {
       return .success
     }
 
-    // Next track command
-    commandCenter.nextTrackCommand.isEnabled = true
+    // Next track â€” isEnabled managed dynamically in updateCommandCenterState
+    commandCenter.nextTrackCommand.isEnabled = false
     commandCenter.nextTrackCommand.addTarget { [weak self] _ in
-      self?.trackPlayerCore?.skipToNext()
+      guard let core = self?.trackPlayerCore else { return .commandFailed }
+      core.skipToNext()
       return .success
     }
 
-    // Previous track command
-    commandCenter.previousTrackCommand.isEnabled = true
+    // Previous track â€” isEnabled managed dynamically in updateCommandCenterState
+    commandCenter.previousTrackCommand.isEnabled = false
     commandCenter.previousTrackCommand.addTarget { [weak self] _ in
-      self?.trackPlayerCore?.skipToPrevious()
+      guard let core = self?.trackPlayerCore else { return .commandFailed }
+      core.skipToPrevious()
       return .success
     }
 
-    // Disable continuous seek commands - they replace the interactive scrubber
-    // with non-interactive forward/backward buttons on the lock screen
+    // Disable skip-forward/backward â€” these replace the scrubber with non-interactive buttons
     commandCenter.seekForwardCommand.isEnabled = false
     commandCenter.seekBackwardCommand.isEnabled = false
 
-    // Change playback position (interactive scrubber)
-    commandCenter.changePlaybackPositionCommand.isEnabled = true
+    // Scrubber â€” isEnabled managed dynamically based on known duration
+    commandCenter.changePlaybackPositionCommand.isEnabled = false
     commandCenter.changePlaybackPositionCommand.addTarget { [weak self] event in
       guard let self = self,
         let core = self.trackPlayerCore,
@@ -120,11 +236,10 @@ class MediaSessionManager {
       else {
         return .commandFailed
       }
-      // Immediately update elapsed time AND set playback rate to 0 during seek
-      // This prevents the scrubber from freezing/desyncing during the async seek operation
+      // Optimistically freeze the scrubber at the tapped position while the async
+      // seek is in flight â€” updateNowPlayingInfo in the seek completion restores it.
       if var info = MPNowPlayingInfoCenter.default().nowPlayingInfo {
         info[MPNowPlayingInfoPropertyElapsedPlaybackTime] = positionEvent.positionTime
-        // Set rate to 0 to pause scrubber animation during seek
         info[MPNowPlayingInfoPropertyPlaybackRate] = 0.0
         MPNowPlayingInfoCenter.default().nowPlayingInfo = info
       }
@@ -133,73 +248,43 @@ class MediaSessionManager {
     }
   }
 
-  private func getCurrentTrack() -> TrackItem? {
-    return trackPlayerCore?.getCurrentTrack()
-  }
-
-  func updateNowPlayingInfo() {
-    guard showInNotification else { return }
-
-    guard let track = getCurrentTrack(),
-      let core = trackPlayerCore
-    else {
-      clearNowPlayingInfo()
-      return
-    }
-
-    let state = core.getState()
+  private func updateCommandCenterState(
+    state: PlayerState,
+    queue: [TrackItem],
+    positionInQueue: Int
+  ) {
+    let commandCenter = MPRemoteCommandCenter.shared()
+    let hasCurrentTrack = positionInQueue >= 0
+    let isNotLast = positionInQueue < queue.count - 1
 
-    // Use player duration if valid, otherwise fall back to track metadata duration.
-    // Duration must always be present for the lock screen scrubber to be interactive.
     let playerDuration = state.totalDuration
-    let effectiveDuration: Double
-    if playerDuration > 0 && !playerDuration.isNaN && !playerDuration.isInfinite {
-      effectiveDuration = playerDuration
-    } else {
-      effectiveDuration = track.duration
-    }
+    let hasDuration = playerDuration > 0 && !playerDuration.isNaN && !playerDuration.isInfinite
 
-    var nowPlayingInfo: [String: Any] = [
-      MPMediaItemPropertyTitle: track.title,
-      MPMediaItemPropertyArtist: track.artist,
-      MPMediaItemPropertyAlbumTitle: track.album,
-      MPNowPlayingInfoPropertyElapsedPlaybackTime: state.currentPosition,
-      MPMediaItemPropertyPlaybackDuration: effectiveDuration,
-      MPNowPlayingInfoPropertyPlaybackRate: state.currentState == .playing ? 1.0 : 0.0,
-    ]
+    // Next: only enabled when there is a track after the current one
+    commandCenter.nextTrackCommand.isEnabled = hasCurrentTrack && isNotLast
 
-    // Add artwork synchronously if cached, otherwise load async
-    if let artwork = track.artwork, case .second(let artworkUrl) = artwork {
-      if let cachedImage = artworkCache[artworkUrl] {
-        // Artwork is cached - include it directly to avoid overwrite race condition
-        nowPlayingInfo[MPMediaItemPropertyArtwork] = MPMediaItemArtwork(
-          boundsSize: CGSize(width: Constants.artworkSize, height: Constants.artworkSize),
-          requestHandler: { _ in cachedImage }
-        )
-      } else {
-        // Artwork not cached - load asynchronously and update later
-        loadArtwork(url: artworkUrl) { [weak self] image in
-          guard let self = self, let image = image else { return }
-          // Re-read current nowPlayingInfo to avoid overwriting other updates
-          var updatedInfo = MPNowPlayingInfoCenter.default().nowPlayingInfo ?? [:]
-          updatedInfo[MPMediaItemPropertyArtwork] = MPMediaItemArtwork(
-            boundsSize: CGSize(width: Constants.artworkSize, height: Constants.artworkSize),
-            requestHandler: { _ in image }
-          )
-          MPNowPlayingInfoCenter.default().nowPlayingInfo = updatedInfo
-        }
-      }
-    }
+    // Previous: always enabled when something is playing â€” either restarts current or goes back
+    commandCenter.previousTrackCommand.isEnabled = hasCurrentTrack
 
-    MPNowPlayingInfoCenter.default().nowPlayingInfo = nowPlayingInfo
+    // Scrubber: only enabled when we have a known, finite duration
+    commandCenter.changePlaybackPositionCommand.isEnabled = hasCurrentTrack && hasDuration
+  }
+
+  private func disableAllCommands() {
+    let commandCenter = MPRemoteCommandCenter.shared()
+    commandCenter.nextTrackCommand.isEnabled = false
+    commandCenter.previousTrackCommand.isEnabled = false
+    commandCenter.changePlaybackPositionCommand.isEnabled = false
   }
 
+  // MARK: - Helpers
+
   private func clearNowPlayingInfo() {
     MPNowPlayingInfoCenter.default().nowPlayingInfo = nil
+    lastArtworkUrl = nil
   }
 
   private func loadArtwork(url: String, completion: @escaping (UIImage?) -> Void) {
-    // Check cache first
     if let cached = artworkCache[url] {
       completion(cached)
       return
@@ -210,33 +295,21 @@ class MediaSessionManager {
       return
     }
 
-    // Load image asynchronously
     URLSession.shared.dataTask(with: imageUrl) { [weak self] data, _, _ in
-      guard let data = data,
-        let image = UIImage(data: data)
-      else {
-        completion(nil)
+      guard let data = data, let image = UIImage(data: data) else {
+        DispatchQueue.main.async { completion(nil) }
         return
       }
-
-      // Cache the image
-      self?.artworkCache[url] = image
       DispatchQueue.main.async {
+        self?.artworkCache[url] = image
         completion(image)
       }
     }.resume()
   }
 
-  func onTrackChanged() {
-    updateNowPlayingInfo()
-  }
-
-  func onPlaybackStateChanged() {
-    updateNowPlayingInfo()
-  }
-
   func release() {
     clearNowPlayingInfo()
+    disableAllCommands()
     artworkCache.removeAll()
   }
 }
