diff --git a/node_modules/react-native-nitro-player/ios/core/TrackPlayerCore.swift b/node_modules/react-native-nitro-player/ios/core/TrackPlayerCore.swift
index de18c45..95e4c38 100644
--- a/node_modules/react-native-nitro-player/ios/core/TrackPlayerCore.swift
+++ b/node_modules/react-native-nitro-player/ios/core/TrackPlayerCore.swift
@@ -399,8 +399,11 @@ class TrackPlayerCore: NSObject {
       let currentItem = player.currentItem
     else {
       NitroPlayerLogger.log("TrackPlayerCore", "âš ï¸ Current item changed to nil")
-      // Queue exhausted â€” handle PLAYLIST repeat
-      if currentRepeatMode == .playlist && !currentTracks.isEmpty, let player = player {
+      // Queue exhausted â€” handle PLAYLIST repeat.
+      // Skip if we're in lazy-load mode (any track still has an empty URL); the queue
+      // was intentionally cleared and updateTracks will rebuild it shortly.
+      let isLazyLoad = currentTracks.contains { $0.url.isEmpty }
+      if currentRepeatMode == .playlist && !currentTracks.isEmpty && !isLazyLoad, let player = player {
         NitroPlayerLogger.log("TrackPlayerCore", "ðŸ” PLAYLIST repeat â€” rebuilding original queue and restarting")
         playNextStack.removeAll()
         upNextQueue.removeAll()
@@ -991,6 +994,27 @@ class TrackPlayerCore: NSObject {
     // Clear old preloaded assets when loading new queue
     preloadedAssets.removeAll()
 
+    // Replace current queue (player should always exist after setupPlayer)
+    guard let existingPlayer = self.player else {
+      NitroPlayerLogger.log("TrackPlayerCore", "âŒ No player available - this should never happen!")
+      return
+    }
+
+    // Always clear old items so no previous playlist can keep playing.
+    NitroPlayerLogger.log("TrackPlayerCore", "ðŸ”„ Removing \(existingPlayer.items().count) old items from player")
+    existingPlayer.removeAllItems()
+
+    // If any track has an empty URL we are in lazy-load mode: URLs haven't been resolved yet.
+    // Don't insert any AVPlayerItems now â€” not even downloaded tracks â€” because doing so
+    // triggers currentItemDidChange which updates currentTrackIndex before skipToIndex runs,
+    // causing the wrong track to play. updateTracks will rebuild from the correct
+    // currentTrackIndex once URL resolution and skipToIndex have both settled.
+    let isLazyLoad = tracks.contains { $0.url.isEmpty }
+    if isLazyLoad {
+      NitroPlayerLogger.log("TrackPlayerCore", "â³ Lazy-load mode â€” player cleared, awaiting URL resolution + skipToIndex")
+      return
+    }
+
     // Create gapless-optimized AVPlayerItems from tracks
     let items = tracks.enumerated().compactMap { (index, track) -> AVPlayerItem? in
       let isPreload = index < Constants.gaplessPreloadCount
@@ -1004,17 +1028,6 @@ class TrackPlayerCore: NSObject {
       return
     }
 
-    // Replace current queue (player should always exist after setupPlayer)
-    guard let existingPlayer = self.player else {
-      NitroPlayerLogger.log("TrackPlayerCore", "âŒ No player available - this should never happen!")
-      return
-    }
-
-    NitroPlayerLogger.log("TrackPlayerCore", "ðŸ”„ Updating queue - removing \(existingPlayer.items().count) items, adding \(items.count) new items")
-
-    // Remove all existing items
-    existingPlayer.removeAllItems()
-
     // Add new items IN ORDER
     // IMPORTANT: insert(after: nil) puts item at the start
     // To maintain order, we need to track the last inserted item
@@ -1685,6 +1698,18 @@ class TrackPlayerCore: NSObject {
     // Update currentTrackIndex BEFORE updating queue
     self.currentTrackIndex = index
 
+    // Lazy-load guard: if any track still has an empty URL, URLs haven't been resolved yet.
+    // Don't insert any AVPlayerItems (not even downloaded ones) â€” doing so triggers
+    // currentItemDidChange which can overwrite currentTrackIndex before updateTracks runs.
+    // updateTracks will rebuild the full queue from currentTrackIndex once URLs are ready.
+    let isLazyLoad = fullPlaylist.contains { $0.url.isEmpty }
+    if isLazyLoad {
+      NitroPlayerLogger.log("TrackPlayerCore", "   â³ Lazy-load mode â€” currentTrackIndex set to \(index), awaiting URL resolution")
+      // Restore the full playlist reference
+      self.currentTracks = fullPlaylist
+      return true
+    }
+
     // Recreate the queue starting from the target index
     // This ensures all remaining tracks are in the queue
     let tracksToPlay = Array(fullPlaylist[index...])
@@ -1732,7 +1757,6 @@ class TrackPlayerCore: NSObject {
     // Start preloading upcoming tracks for gapless playback
     self.preloadUpcomingTracks(from: index + 1)
 
-    player.play()
     return true
   }
 
@@ -1904,13 +1928,17 @@ class TrackPlayerCore: NSObject {
 
       NitroPlayerLogger.log("TrackPlayerCore", "ðŸ”„ updateTracks: \(tracks.count) updates")
 
-      // Get current track ID to avoid updating it (preserves gapless playback)
-      let currentTrackId = self.getCurrentTrack()?.id
+      // Get current track to check if it has a URL yet (lazy-loaded initial state)
+      let currentTrack = self.getCurrentTrack()
+      let currentTrackId = currentTrack?.id
+      let currentTrackNeedsUrl = currentTrack?.url.isEmpty ?? false
 
-      // Filter out current track and validate
+      // Filter out current track only if it already has a valid URL (preserves gapless playback).
+      // If the current track has an empty URL it was never loadable - allow the update so
+      // the player can actually start.
       let safeTracks = tracks.filter { track in
         switch true {
-        case track.id == currentTrackId:
+        case track.id == currentTrackId && !currentTrackNeedsUrl:
           NitroPlayerLogger.log(
             "TrackPlayerCore",
             "âš ï¸ Skipping update for currently playing track: \(track.id) (preserves gapless)")
@@ -1951,12 +1979,43 @@ class TrackPlayerCore: NSObject {
           "TrackPlayerCore",
           "ðŸ”„ Rebuilding queue - \(updateCount) tracks updated in current playlist")
 
-        // This method preserves current item
-        self.rebuildAVQueueFromCurrentPosition()
+        // Sync in-memory currentTracks with the playlist manager's updated data so that
+        // rebuildAVQueueFromCurrentPosition uses the fresh URLs
+        if let updatedPlaylist = self.playlistManager.getPlaylist(playlistId: currentId) {
+          self.currentTracks = updatedPlaylist.tracks
+        }
+
+        if self.player?.currentItem == nil, let player = self.player {
+          // No AVPlayerItem exists at all â€” the track's URL was empty when the queue was
+          // first loaded (lazy URL case, NOT a download). Rebuild from currentTrackIndex
+          // using removeAllItems so we don't disturb an index that skipToIndex already set.
+          NitroPlayerLogger.log(
+            "TrackPlayerCore",
+            "ðŸ”„ No current item - rebuilding from currentTrackIndex \(self.currentTrackIndex)")
+
+          player.removeAllItems()
 
-        // Re-preload upcoming tracks for gapless playback
-        // CRITICAL: This restores gapless buffering after queue rebuild
-        self.preloadUpcomingTracks(from: self.currentTrackIndex + 1)
+          // Insert tracks starting from currentTrackIndex, preserving that index
+          var lastItem: AVPlayerItem? = nil
+          for (offset, track) in self.currentTracks[self.currentTrackIndex...].enumerated() {
+            let isPreload = offset < Constants.gaplessPreloadCount
+            if let newItem = self.createGaplessPlayerItem(for: track, isPreload: isPreload) {
+              player.insert(newItem, after: lastItem)
+              lastItem = newItem
+            }
+          }
+
+          self.preloadUpcomingTracks(from: self.currentTrackIndex + 1)
+        } else {
+          // A current AVPlayerItem already exists (stream that was mid-play, or a downloaded
+          // track whose local-file item is valid even though TrackItem.url is empty).
+          // Preserve it and only rebuild the upcoming items.
+          self.rebuildAVQueueFromCurrentPosition()
+
+          // Re-preload upcoming tracks for gapless playback
+          // CRITICAL: This restores gapless buffering after queue rebuild
+          self.preloadUpcomingTracks(from: self.currentTrackIndex + 1)
+        }
 
         NitroPlayerLogger.log("TrackPlayerCore", "âœ… Queue rebuilt, gapless playback preserved")
       }
@@ -2099,8 +2158,17 @@ class TrackPlayerCore: NSObject {
    * Call this in playerItemDidPlayToEndTime or after skip operations
    */
   private func checkUpcomingTracksForUrls(lookahead: Int = 5) {
+    var tracksNeedingUrls: [TrackItem] = []
+
+    // Also check the current track - if it has no URL it must be populated before playback can begin
+    if let currentTrack = getCurrentTrack(), currentTrack.url.isEmpty {
+      NitroPlayerLogger.log(
+        "TrackPlayerCore", "âš ï¸ Current track needs a URL: \(currentTrack.title)")
+      tracksNeedingUrls.append(currentTrack)
+    }
+
     let nextTracks = getNextTracksInternal(count: lookahead)
-    let tracksNeedingUrls = nextTracks.filter { $0.url.isEmpty }
+    tracksNeedingUrls += nextTracks.filter { $0.url.isEmpty }
 
     if !tracksNeedingUrls.isEmpty {
       NitroPlayerLogger.log(
